\chapter {固定小数点を用いた数値計算の提案}
\label{chap:提案手法}
\begin{comment}
    ストーリー：
    固定小数点演算は浮動小数点演算よりも計算時間が速いとされている．
    しかし，浮動小数点に比べて精度が低くなる恐れがある．
    本論文では，固定小数点と浮動小数点での数値計算の結果を比べ，固定小数点での演算も浮動小数点と同程度の精度で計算できることを示した．
    実験結果より固定小数点演算で浮動小数点より高速で，浮動小数点と同程度の計算を実現できるのではないかと考える．
\end{comment}
本論文で行う実験は，数値計算を固定小数点によって計算することである．
本章では，固定小数点と浮動小数点の表現できる数の範囲や丸め誤差の大きさ，演算の違いについて述べる．
第\ref{chap:基礎知識1}で述べたように，固定小数点と浮動小数点では表現方法が異なる．
そのため，固定小数点と浮動小数点には利点と欠点が存在する．
本章では固定小数点と浮動小数点の利点と欠点を述べ，固定小数点の利点を活かした数値計算を行うことを提案する．

\section{固定小数点と浮動小数点の表現できる範囲と丸め誤差}
固定小数数点と浮動小数点では，表現方法が異なるためそれぞれに利点が存在する．
浮動小数点の利点は，表現できる数の範囲が同じbit数の固定小数点よりも広いことである．
例として，同じ64bitの固定小数点と倍精度浮動小数点(Float64)を考える．
表\ref{tab:fixed_float_range}は，固定小数点と浮動小数点の表現できる数の範囲を示したものである．

\begin{table}[H]
    \centering
    \caption{固定小数点(Q11f52，Q62f1)と浮動小数点(Float64)の表現できる数の範囲}
    \begin{tabular}{c|c|c}
         & 最小値 & 最大値　\\ \hline\hline
          Float64 & $-1.798 \times 10^{308}$ & $1.798 \times 10^{308}$ \\
          Q11f52 & $-2048$ & $2048$ \\
          Q62f1 & $-4.612 \times 10^{18}$ & $-4.612 \times 10^{18}$
    \end{tabular}
    \label{tab:fixed_float_range}
\end{table}

表\ref{tab:fixed_float_range}で示したのは倍精度浮動小数点(Float64)と，小数部のbit数が倍精度浮動小数点(Float64)の仮数部と同じbit数の固定小数点(Q11f52)と64bitの固定小数点のうち表現できる数の範囲が最大の固定小数点(Q62f1)の表現できる数の範囲である．
この表から分かるように，浮動小数点の方が表現できる数の範囲が固定小数点に比べとても大きい．
数値計算を行う際に，計算の過程で扱う数が計算機で扱う数の範囲を超えてしまうオーバーフローという現象が発生する心配がある．
浮動小数点は，固定小数数点に比べ表現できる数の範囲が広いため，固定小数点に比べオーバーフローが起こりにくいという利点がある．

次に，固定小数点と浮動小数点の丸め誤差について述べる．
第\ref{chap:基礎知識2}で述べたように，固定小数点の丸め誤差の最大値は真の値によらず一定であるのに対して，浮動小数点の丸め誤差の最大値は真の値の絶対値の大きさによって異なる．
表\ref{tab:fixed_float_rounding_error}は同じ64bitの倍精度浮動小数点(Float64)と倍精度浮動小数点(Float64)の仮数部と同じbit数の小数部を持つ固定小数点(Q11f52)の丸め誤差を表したものである．

\begin{table}[H]
    \centering
    \caption{固定小数点(Q11f52)と浮動小数点(Float64)のそれぞれの数値に対する丸め誤差の大きさ}
    \begin{tabular}{c|c|c}
        & Q11f52 & Float64 \\ \hline \hline
        0.01 & $8.674 \times 10^{-18}$ & $1.735 \times 10^{-18}$\\
        0.1 & $8.327 \times 10^{-17}$ & $1.388 \times 10^{-17}$\\
        1.1 & $8.327 \times 10^{-17}$ & $2.220 \times 10^{-16}$\\
        10.1 & $8.327 \times 10^{-17}$ & $1.776 \times 10^{-15}$\\
        100.1 & $8.327 \times 10^{-17}$ & $1.421 \times 10^{-14}$ 
    \end{tabular}
    \label{tab:fixed_float_rounding_error}
\end{table}

このように，固定小数点は，$1$よりも大きい数に対しては丸め誤差の値が一定であるのに対して，浮動小数点は，絶対値の小さい数に対しては丸め誤差の値も小さく，絶対値の大きい数に対しては丸め誤差の値も大きくなる．
固定小数点は，小数部のbit数が同じでありるため表現できる数の中で隣り合う2数の間隔が一定であるのに対して，浮動小数点は表現できる2数の間隔が2数の絶対値の大きさによって異なる．
そのため，固定小数点と浮動小数点では丸め誤差が真の値によって異なる．
また，数値計算において絶対値がとても小さい数を表現できなくなるアンダーフローという現象がある．
表\ref{tab:fixed_float_zero_error}は固定小数点(Q11f52，Q1f62)と浮動小数点(Float64)の$0$に最も近い値を示したものである．

\begin{table}[H]
    \centering
    \caption{固定小数点(Q11f52，Q1f62)と浮動小数点(Float64)の$0$に最も近い値}
    \begin{tabular}{c|c}
        & $0$に最も近い数 \\ \hline \hline
        Float64 & $2.225 \times 10^{-308}$\\
        Q11f52  & $2.220 \times 10^{-16}$\\
        Q1f62   & $2.168 \times 10^{-19} $
    \end{tabular}
    \label{tab:fixed_float_zero_error}
\end{table}

このように，浮動小数点は絶対値のとても小さい数も表現できるため，固定小数点に比べアンダーフローを起こしにくいという利点がある．


固定小数点と浮動小数点の表現できる数の中で隣り合う2数の間隔を表したイメージ図が図\ref{fig:fixed_float_image}である．

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[scale=0.92]
        \draw [->, thick] (-7,0) -- (7,0);
        \draw [->, thick] (0,-1) -- (0,4);
        \node [below left] at (0,0) {$0$};
        \node [below right] at (7,0) {表現できる数};
        \node [above] at (0,4) {隣り合う2数の間隔};
        \begin{scope}
            \clip(0,-1) rectangle (7,4);
            \draw[thick] plot(\x,{pow(1.5,\x)-1});
        \end{scope}
        \begin{scope}
            \clip(-7,-1) rectangle (0,4);
            \draw[thick] plot(\x,{pow(1.5,-\x)-1});
        \end{scope}
        \node[right] at (4,{pow(1.5,4)-1}) {浮動小数点};
        \draw[thick] (-3,1) -- (3,1) node[right] {固定小数点数};
        \draw[thick] (-4,2) -- (4,2) node[right] {固定小数点数};
    \end{tikzpicture}
    \caption{固定小数点と浮動小数点の表現できる数の中で隣り合う2数の間隔のイメージ図．}
    \label{fig:fixed_float_image}
\end{figure}

浮動小数点は固定小数点に比べ，表現できる数の範囲が広く，オーバーフローやアンダーフローが起こる可能性が低いという利点がる．
その一方で，表現できる数の中で隣り合う間隔が数の絶対値の大きさによって異なる．
そのため，図\ref{fig:fixed_float_image}で固定小数点のグラフが浮動小数点のグラフの下に来ている範囲では固定小数点の方が丸め誤差を少なくして計算が行える．
図\ref{fig:fixed_float_image_zoom}は図\ref{fig:fixed_float_image}の一部を拡大し，固定小数点の方が浮動小数点よりも丸め誤差が少ない範囲を示した図である．

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[scale=0.92]
        \fill[lightgray] (3,-1)--(3,4)--(6,4)--(6,-1);
        \draw[->, thick] (-1,0) -- (9,0);
        \draw[->, thick] (0,-1) -- (0,4);
        \node [below left] at (0,0) {$0$};
        \node [below right] at (9,0) {表現できる数};
        \node [above] at (0,4) {隣り合う2数の間隔};

        \draw[thick,domain=0:7] plot(\x,{pow(1.2,\x)-1});
        \draw[thick,domain=0:7] plot(\x,1);

        \node[above] at (7,{pow(1.2,7)-1}) {浮動小数点};
        \node[right] at (7,1) {固定小数点};
    \end{tikzpicture}
    \caption{固定小数点と浮動小数点の表現できる数の中で隣り合う2数の間隔のイメージ図(グレーの部分が固定小数点の方が浮動小数点よりも誤差を小さくすることができる範囲)．}
    \label{fig:fixed_float_image_zoom}
\end{figure}

\section{固定小数点と浮動小数点の演算の違い}
計算機の中で主に演算を行うのはCPU(Central Processing Unit)である．
固定小数点と浮動小数点では，演算におけるCPUへの負担が異なり浮動小数点の方が負荷が大きい．
そのため，かつてはCPUの性能が低く浮動小数点を専門に扱うためのFPU(Floating Point Unit)を用いて浮動小数点演算を行なっていた．
現代では，CPUの性能が向上したためFPUの機能はCPU自体に組み込まれていることが多い．
しかし，浮動小数点演算を組み込まずに固定小数点演算を行うような計算機があれば，計算の負荷を少なくすることが可能である．
以下では，固定小数点と浮動小数点の演算の違いについて述べる．

\subsection{固定小数点の演算}
固定小数数点の四則演算は，整数での四則演算と同様に行える．
例えば，整数部が3bitで小数部が4bitの符号あり固定小数点$\fixnumcustom{3}{4}$の四則演算を行う場合を考える．
2数$0010.1101_{\fixnumcustom{3}{4}} \ (= 2.8125)$と$0010.1110_{\fixnumcustom{3}{4}} \ (= 2.875)$の加法を行う場合，2数に小数部と同じbit数分だけ2をかける．
つまり，2数を$2^4$倍して，整数$00101101_{(2)}$と$00101110_{(2)}$を加算することで，整数同士の演算を行い，その計算結果を最初にかけた数でわることで結果を求めることができる．
数式で表すと式(\ref{eq:fixed_add_first})〜(\ref{eq:fixed_add_last})のようになる．
\begin{align}
    2.8125 + 2.875 &=
    0010.1101_{\fixnumcustom{3}{4}} + 0010.1110_{\fixnumcustom{3}{4}} \label{eq:fixed_add_first} \\
    &= \left\{ 2^4 \times \left(0010.1101_{\fixnumcustom{3}{4}} + 0010.1110_{\fixnumcustom{3}{4}}\right) \right\} \div 2^4 \\
    &= \left(00101101_{(2)} + 00101110_{(2)} \right) \div 2^4= 01011011_{(2)} \div 2^4\\
    &= 91 \div 2^4 = 5.6875 \label{eq:fixed_add_last}
\end{align}

数式での厳密な四則演算を$+,-,\times,\div$，計算機内の四則演算を$\fixadd,\fixsub ,\fixmul,\\ \fixdiv$と表すことにする．
また，2数の演算結果も数値型の表せる範囲内であるのもとし，実数$a$に対して計算機で$a$を表す数を$a^{\ast}$とする．
加法と減法については，数式と同じように行うことができ，$a+b$，$a-b$を計算機で行うと，
\begin{align*}
    a^{\ast} \fixadd b^{\ast} &= a^{\ast} + b^{\ast}, \\ 
    a^{\ast} \fixsub b^{\ast} &= a^{\ast} - b^{\ast}
\end{align*}
となる．
乗法については，数式で厳密な計算を行うと$m$桁の数と$m$桁の数同士の乗法の演算結果は最大で$2m$桁になるため，表現が可能な小数部のbit数までで打ち切る．
$a \times b$を計算機内で行うと，
\begin{align*}  
    a^{\ast} \fixmul b^{\ast} = \left(a^{\ast} \times b^{\ast}\right)^{\ast}
\end{align*}
となる．
例として，

除法については，数式での厳密な計算では，割り切れないこともあり商が循環小数となる場合もある．
そのため，乗算の場合と同じく表現できる小数部のbit数までで打ち切る．
$a \div b$を計算機内で行うと，
\begin{align*}
    a^{\ast} \fixdiv b^{\ast} = \left(a^{\ast} \div b^{\ast}\right)^{\ast}
\end{align*}
となる．
例として，


固定小数点の乗算，除算では表現できる小数部のbit数までで打ち切るため，誤差が発生するが基本的な演算は数式での四則演算と同じである．

\subsection{浮動小数点の演算}
浮動小数点は，与えられたbit数を仮数部と指数部という二つの部分に分けて表現するため，四則演算を行うときに注意が必要である．
数式での厳密な四則演算を$+,-,\times,\div$とし，計算機内での四則演算を$\floadd,\flosub,\floomul,\flodiv$と表すことにする．

実数$a$に対して計算機内で$a$を表す数を$a^{\ast}$とし，$a^{\ast}$の指数部を$e_{a^{\ast}}$，仮数部を$m_{a^{\ast}}$とする．
行う手順については，計算機の使用などによって順番は異なる場合もあるが捜査としては同じことを行う．
加法については，$a + b$を計算機で行う手順は，
\begin{enumerate}
    \item 指数部$e_{a^{\ast}}$と$e_{b^{\ast}}$を比較し，仮数部$m_{a^{\ast}}$と$m_{b^{\ast}}$の桁を揃える．
    \item 桁を揃えた仮数部$m_{a^{\ast}}$と$m_{b^{\ast}}$を加算する．
    \item 桁を揃えた仮数部の計算結果をもとに，計算結果の指数部と仮数部を決める．
    \item 符号を調整する．
\end{enumerate}
となる．
例として，

減法については，$a - b$を計算機で行う手順は，
\begin{enumerate}
    \item 指数部$e_{a^{\ast}}$と$e_{b^{\ast}}$を比較し，仮数部$m_{a^{\ast}}$と$m_{b^{\ast}}$の桁を揃える．
    \item 桁を揃えた仮数部$m_{a^{\ast}}$と$m_{b^{\ast}}$を減算する．
    \item 桁を揃えた仮数部の計算結果をもとに，計算結果の指数部と仮数部を決める．
    \item 符号を調整する．
\end{enumerate}
となる．

乗算については，$a \times b$を計算機で行う手順は，
\begin{enumerate}
    \item 指数部$e_{a^{\ast}}$と$e_{b^{\ast}}$を加算する．
    \item 仮数部$m_{a^{\ast}}$と$m_{b^{\ast}}$の乗算を行う．
    \item 仮数部の計算結果を指数部に反映させて計算結果の指数部と仮数部を決める．
    \item 符号を調整する．
\end{enumerate}
となる．
例として，

除法については，$a \div b$を計算機で行う手順は，
\begin{enumerate}
    \item 指数部$e_{a^{\ast}}$と$e_{b^{\ast}}$を減算する．
    \item 仮数部$m_{a^{\ast}}$と$m_{b^{\ast}}$の除算を行う．
    \item 仮数部の計算結果を指数部に反映させて計算結果の指数部と仮数部を決める．
    \item 符号を調整する．
\end{enumerate}
となる．
例として，

以上から，固定小数点に比べ浮動小数点の計算は，手順が多く一回の計算あたりにかかる計算機への負荷が大きい．
そのため，固定小数点の方が計算負荷が少ないという利点がある．
\section{提案}
先行研究では，小数部が11bitの固定小数点を用いて，浮動小数点よりも速い計算時間で連立方程式や高次方程式の近似解を求めるている\cite{IJERTV12IS010134}．
しかし，\cite{IJERTV12IS010134}において，精度に関しては浮動小数点の方が精度が高いことも示されている．
また，32bitの固定小数点を用いて微分方程式を解き32bitの単精度浮動小数点(Float32)と比較し，浮動小数点よりも精度の良い結果を得られることが示されている\cite{hopkins2020stochastic}．
\cite{hopkins2020stochastic}では，計算時に計算機にかかる負荷が固定小数点の方が浮動小数点比べ低いことは示唆されているが，使用した固定小数点はISO18037の規格に従った数値型(s16.15,u0.32,s0.31,s8.7,u0.16,s0.15)であり，いずれも32bit以下の固定小数点である．
現在，多くのプログラミング言語では通常使われる浮動小数点は64bitの倍精度浮動小数点(Float64)であり，32bitの単精度浮動小数点(Float32)よりも精度が高い計算が行える．
そこで，倍精度浮動小数点(Float64)と同じ64bitの固定小数点を用い，また演算が行える範囲内で最大限小数部のbit数を増やすことによって倍精度浮動小数点(Float64)よりも計算の精度を高めることができるのではないかと考える．
固定小数点を用いた計算をサポートしている言語(C,C++等)はまだ少なく，多くの数値計算では浮動小数点を用いるのが一般的であるが，将来的に固定小数点での演算のために最適化された計算機やプログラミング言語の開発が行なわれれば，固定小数点を用いた計算負荷が少なく計算時間が短く浮動小数点よりも精度の高い計算を行えることが可能になるのではないかと考える．

\begin{comment} 
そのため，固定小数点と浮動小数点では計算の過程で扱う数の範囲によって計算機の中で表現できる数の個数が異なる． %この文変だなぁ。
本論文では，ある数値型$\mathrm{T}$と計算機で扱う数の範囲$I \subset \R$を用いて，範囲$I$での数値型$\mathrm{T}$の密度${|I|}_{\mathrm{T}}$を以下のように定義する．
\begin{align}
    \label{eq:def_density}
    {|I|}_{\mathrm{T}}: \text{集合}\left\{x^{\ast} \ | \ x^{\ast} \in \mathbb{F}_{\mathrm{T}} \cap I \right\}\text{の要素の数．}
\end{align}
ただし，数値型$\mathrm{T}$で表せる最大の数を$M_{\mathrm{T}}$，最小の数を$m_{\mathrm{T}}$とし，
\begin{equation}
    I \subset (m_{\mathrm{T}}, M_{\mathrm{T}})
\end{equation}
とする．
例として，8bitの固定小数点(Q4f3)を考える．
このとき，
\begin{align}
    m_{\mathrm{Q}4\mathrm{f}3} &= -14.875, \\
    M_{\mathrm{Q}4\mathrm{f}3} &= 14.875
\end{align}
であり，$I$を
\begin{eqnarray}
    I = \left(-3,2\right)
\end{eqnarray}
とすると，${|\left(-3,2\right)|}_{\mathrm{Q}4\mathrm{f}3}$は，
\begin{align}
    &\left\{x^{\ast}\in \fixnumcustom{4}{3} \cap (-3,2)\right\} \\
    &= \left\{-2.875,-2.750,-2.625,\dots,1.625,1.750,1.875\right\}
\end{align}
となるため，
\begin{align}
    {|I|}_{\mathrm{Q}4\mathrm{f}3} = 39
\end{align}
となる．
このように定義した密度${|I|}_{\mathrm{T}}$を用いて，同じ範囲$J \in \R$に対して異なる数値型$T_1,T_2$で計算を行うことを考える．
ただし，
\begin{equation}
    J \subset (m_{T_1}, M_{T_1}) \cap (m_{T_2}, M_{T_2})
\end{equation}
とする．
また，
\begin{equation}
    \label{eq:density_compare}
    {|J|}_{T_1} < {|J|}_{T_2}
\end{equation}
と仮定する．

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \node[text=red] (A-4) at (-3.5,0) {$\bigtriangleup$};
        \node[text=red] (A-3) at (-2.2,0) {$\bigtriangleup$};
        \node[text=red] (A-2) at (-2,0) {$\bigtriangleup$};
        \node[text=red] (A-1) at (-1,0) {$\bigtriangleup$};
        \node[text=red] (A0) at (0,0) {$\bigtriangleup$}; 
        \node[text=red] (A1) at (1,0) {$\bigtriangleup$};
        \node[text=red] (A2) at (2.1,0) {$\bigtriangleup$};
        \node[text=red] (A3) at (2.6,0) {$\bigtriangleup$};
        \node[text=red] (A4) at (3.1,0) {$\bigtriangleup$};
        \node[text=red] (A5) at (4.7,0) {$\bigtriangleup$};
        \node[text=red] (A6) at (5.5,0) {$\bigtriangleup$};
        \draw [->, thick] (-7,0) -- (7,0);
        \node[left] (X) at (8,0) {$x$};
        \node[text=blue] (B-5) at (-5.7,0) {$\square$};
        \node[text=blue] (B-4) at (-4.5,0) {$\square$};
        \node[text=blue] (B-3) at (-3.1,0) {$\square$};
        \node[text=blue] (B-2) at (-2.5,0) {$\square$};
        \node[text=blue] (B-1) at (-1.3,0) {$\square$};
        \node[text=blue] (B0) at (0.4,0) {$\square$};
        \node[text=blue] (B1) at (1.5,0) {$\square$};
        \node[text=blue] (B2) at (3.2,0) {$\square$};
        \node[text=blue] (B3) at (4.5,0) {$\square$};
        \node[text=blue] (B4) at (6.5,0) {$\square$};
        \draw[very thick] (-2.5,-1) -- (-3,-1) -- (-3,1) -- (-2.5,1);
        \draw[very thick] (2.5,-1) -- (3,-1) -- (3,1) -- (2.5,1);
        \node (J) at (0,1) {$J$};
        \node[text=blue] (B) at (7,1.5) {$\square$};
        \node (Bname) at (7.5,1.5) {$T_{1}$};
        \node[text=red] (A) at (7,1.1) {$\bigtriangleup$};
        \node (Aname) at (7.5,1.1) {$T_{2}$};
        \end{tikzpicture}
        \caption{${|J|}_{T_1} < {|J|}_{T_2}$を満たす場合のイメージ図：横軸は数直線，青色の\textcolor{blue}{$\square$}は数値型($T_{1}$)の表せる数，赤色の\textcolor{red}{$\bigtriangleup$}は数値型($T_{2}$)の表せる数}
\end{figure}
式(\ref{eq:density_compare})を満たすような範囲$J$において数値計算を行う場合，密度の高い数値型$T_{2}$の方が数値型$T_{1}$よりも計算の際に生じる誤差が少ないと予想される．
つまり，$J$において数値型$T_1$で行なった計算と，数値型$T_2$で行なった計算の誤差をそれぞれ$e_1$，$e_2$とすると，
\begin{equation}
    e_2 < e_1
\end{equation}
となると考えられる．
次章で行う数値実験は，倍精度浮動小数点(Float64)よりも64bitの固定小数点の方が密度が高いと思われる範囲での数値計算を行った．
\end{comment}