\chapter {固定小数点と浮動小数点の違い}
\label{chap:提案手法}
\begin{comment}
    ストーリー：
    固定小数点演算は浮動小数点演算よりも計算時間が速いとされている．
    しかし，浮動小数点に比べて精度が低くなる恐れがある．
    本論文では，固定小数点と浮動小数点での数値計算の結果を比べ，固定小数点での演算も浮動小数点と同程度の精度で計算できることを示した．
    実験結果より固定小数点演算で浮動小数点より高速で，浮動小数点と同程度の計算を実現できるのではないかと考える．
\end{comment}
本論文で行う実験は，数値計算を固定小数点によって計算することである．
本章では，固定小数点と浮動小数点の表現できる数の範囲や丸め誤差の大きさ，演算の違いについて述べる．
第\ref{chap:基礎知識1}で述べたように，固定小数点と浮動小数点では表現方法が異なる．
そのため，固定小数点と浮動小数点には利点と欠点が存在する．

\section{固定小数点と浮動小数点の表現できる範囲と丸め誤差}
固定小数数点と浮動小数点では，表現方法が異なるためそれぞれに利点が存在する．
浮動小数点の利点は，表現できる数の範囲が同じbit数の固定小数点よりも広いことである．
例として，同じ64bitの固定小数点と倍精度浮動小数点(Float64)を考える．
表\ref{tab:fixed_float_range}は，固定小数点と浮動小数点の表現できる数の範囲を示したものである．

\begin{table}[H]
    \centering
    \caption{固定小数点(Q11f52，Q62f1)と浮動小数点(Float64)の表現できる数の範囲}
    \begin{tabular}{c|c|c}
         & 最小値 & 最大値　\\ \hline\hline
          Float64 & $-1.798 \times 10^{308}$ & $1.798 \times 10^{308}$ \\
          Q11f52 & $-2048$ & $2048$ \\
          Q62f1 & $-4.612 \times 10^{18}$ & $-4.612 \times 10^{18}$
    \end{tabular}
    \label{tab:fixed_float_range}
\end{table}

表\ref{tab:fixed_float_range}で示したのは倍精度浮動小数点(Float64)と，小数部のbit数が倍精度浮動小数点(Float64)の仮数部と同じbit数の固定小数点(Q11f52)と64bitの固定小数点のうち表現できる数の範囲が最大の固定小数点(Q62f1)の表現できる数の範囲である．
この表から分かるように，浮動小数点の方が表現できる数の範囲が固定小数点に比べとても大きい．
数値計算を行う際に，計算の過程で扱う数が計算機で扱う数の範囲を超えてしまうオーバーフローという現象が発生する心配がある．
浮動小数点は，固定小数数点に比べ表現できる数の範囲が広いため，固定小数点に比べオーバーフローが起こりにくいという利点がある．

次に，固定小数点と浮動小数点の丸め誤差について述べる．
第\ref{chap:基礎知識2}で述べたように，固定小数点の丸め誤差の最大値は真の値によらず一定であるのに対して，浮動小数点の丸め誤差の最大値は真の値の絶対値の大きさによって異なる．
表\ref{tab:fixed_float_rounding_error}は同じ64bitの倍精度浮動小数点(Float64)と倍精度浮動小数点(Float64)の仮数部と同じbit数の小数部を持つ固定小数点(Q11f52)の丸め誤差を表したものである．

\begin{table}[H]
    \centering
    \caption{固定小数点(Q11f52)と浮動小数点(Float64)のそれぞれの数値に対する丸め誤差の大きさ}
    \begin{tabular}{c|c|c}
        & Q11f52 & Float64 \\ \hline \hline
        0.01 & $8.674 \times 10^{-18}$ & $1.735 \times 10^{-18}$\\
        0.1 & $8.327 \times 10^{-17}$ & $1.388 \times 10^{-17}$\\
        1.1 & $8.327 \times 10^{-17}$ & $2.220 \times 10^{-16}$\\
        10.1 & $8.327 \times 10^{-17}$ & $1.776 \times 10^{-15}$\\
        100.1 & $8.327 \times 10^{-17}$ & $1.421 \times 10^{-14}$ 
    \end{tabular}
    \label{tab:fixed_float_rounding_error}
\end{table}

このように，固定小数点は，$1$よりも大きい数に対しては丸め誤差の値が一定であるのに対して，浮動小数点は，絶対値の小さい数に対しては丸め誤差の値も小さく，絶対値の大きい数に対しては丸め誤差の値も大きくなる．
固定小数点は，小数部のbit数が同じでありるため表現できる数の中で隣り合う2数の間隔が一定であるのに対して，浮動小数点は表現できる2数の間隔が2数の絶対値の大きさによって異なる．
そのため，固定小数点と浮動小数点では丸め誤差が真の値によって異なる．
また，数値計算において絶対値がとても小さい数を表現できなくなるアンダーフローという現象がある．
表\ref{tab:fixed_float_zero_error}は固定小数点(Q11f52，Q1f62)と浮動小数点(Float64)の$0$に最も近い値を示したものである．

\begin{table}[H]
    \centering
    \caption{固定小数点(Q11f52，Q1f62)と浮動小数点(Float64)の$0$に最も近い値}
    \begin{tabular}{c|c}
        & $0$に最も近い数 \\ \hline \hline
        Float64 & $2.225 \times 10^{-308}$\\
        Q11f52  & $2.220 \times 10^{-16}$\\
        Q1f62   & $2.168 \times 10^{-19} $
    \end{tabular}
    \label{tab:fixed_float_zero_error}
\end{table}

このように，浮動小数点は絶対値のとても小さい数も表現できるため，固定小数点に比べアンダーフローを起こしにくいという利点がある．


固定小数点と浮動小数点の表現できる数の中で隣り合う2数の間隔を表したイメージ図が図\ref{fig:fixed_float_image}である．

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[scale=0.92]
        \draw [->, thick] (-7,0) -- (7,0);
        \draw [->, thick] (0,-1) -- (0,4);
        \node [below left] at (0,0) {$0$};
        \node [below right] at (7,0) {表現できる数};
        \node [above] at (0,4) {隣り合う2数の間隔};
        \begin{scope}
            \clip(0,-1) rectangle (7,4);
            \draw[thick] plot(\x,{pow(1.5,\x)-1});
        \end{scope}
        \begin{scope}
            \clip(-7,-1) rectangle (0,4);
            \draw[thick] plot(\x,{pow(1.5,-\x)-1});
        \end{scope}
        \node[right] at (4,{pow(1.5,4)-1}) {浮動小数点};
        \draw[thick] (-3,1) -- (3,1) node[right] {固定小数点数};
        \draw[thick] (-4,2) -- (4,2) node[right] {固定小数点数};
    \end{tikzpicture}
    \caption{固定小数点と浮動小数点の表現できる数の中で隣り合う2数の間隔のイメージ図．}
    \label{fig:fixed_float_image}
\end{figure}

浮動小数点は固定小数点に比べ，表現できる数の範囲が広く，オーバーフローやアンダーフローが起こる可能性が低いという利点がる．
その一方で，表現できる数の中で隣り合う間隔が数の絶対値の大きさによって異なる．
そのため，図\ref{fig:fixed_float_image}で固定小数点のグラフが浮動小数点のグラフの下に来ている範囲では固定小数点の方が丸め誤差を少なくして計算が行える．
図\ref{fig:fixed_float_image_zoom}は図\ref{fig:fixed_float_image}の一部を拡大し，固定小数点の方が浮動小数点よりも丸め誤差が少ない範囲を示した図である．

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[scale=0.92]
        \fill[lightgray] (3,-1)--(3,4)--(6,4)--(6,-1);
        \draw[->, thick] (-1,0) -- (9,0);
        \draw[->, thick] (0,-1) -- (0,4);
        \node [below left] at (0,0) {$0$};
        \node [below right] at (9,0) {表現できる数};
        \node [above] at (0,4) {隣り合う2数の間隔};

        \draw[thick,domain=0:7] plot(\x,{pow(1.2,\x)-1});
        \draw[thick,domain=0:7] plot(\x,1);

        \node[above] at (7,{pow(1.2,7)-1}) {浮動小数点};
        \node[right] at (7,1) {固定小数点};
    \end{tikzpicture}
    \caption{固定小数点と浮動小数点の表現できる数の中で隣り合う2数の間隔のイメージ図(グレーの部分が固定小数点の方が浮動小数点よりも誤差を小さくすることができる範囲)．}
    \label{fig:fixed_float_image_zoom}
\end{figure}

\section{固定小数点と浮動小数点の演算の違い}
計算機の中で主に演算を行うのはCPU(Central Processing Unit)である．
固定小数点と浮動小数点では，演算におけるCPUへの負担が異なり浮動小数点の方が負荷が大きい．
そのため，かつてはCPUの性能が低く浮動小数点を専門に扱うためのFPU(Floating Point Unit)を用いて浮動小数点演算を行なっていた．
現代では，CPUの性能が向上したためFPUの機能はCPU自体に組み込まれていることが多い．
しかし，浮動小数点演算を組み込まずに固定小数点演算を行うような計算機があれば，計算の負荷を少なくすることが可能である．
以下では，固定小数点と浮動小数点の演算の違いについて述べる．
\begin{comment} 
そのため，固定小数点と浮動小数点では計算の過程で扱う数の範囲によって計算機の中で表現できる数の個数が異なる． %この文変だなぁ。
本論文では，ある数値型$\mathrm{T}$と計算機で扱う数の範囲$I \subset \R$を用いて，範囲$I$での数値型$\mathrm{T}$の密度${|I|}_{\mathrm{T}}$を以下のように定義する．
\begin{align}
    \label{eq:def_density}
    {|I|}_{\mathrm{T}}: \text{集合}\left\{x^{\ast} \ | \ x^{\ast} \in \mathbb{F}_{\mathrm{T}} \cap I \right\}\text{の要素の数．}
\end{align}
ただし，数値型$\mathrm{T}$で表せる最大の数を$M_{\mathrm{T}}$，最小の数を$m_{\mathrm{T}}$とし，
\begin{equation}
    I \subset (m_{\mathrm{T}}, M_{\mathrm{T}})
\end{equation}
とする．
例として，8bitの固定小数点(Q4f3)を考える．
このとき，
\begin{align}
    m_{\mathrm{Q}4\mathrm{f}3} &= -14.875, \\
    M_{\mathrm{Q}4\mathrm{f}3} &= 14.875
\end{align}
であり，$I$を
\begin{eqnarray}
    I = \left(-3,2\right)
\end{eqnarray}
とすると，${|\left(-3,2\right)|}_{\mathrm{Q}4\mathrm{f}3}$は，
\begin{align}
    &\left\{x^{\ast}\in \fixnumcustom{4}{3} \cap (-3,2)\right\} \\
    &= \left\{-2.875,-2.750,-2.625,\dots,1.625,1.750,1.875\right\}
\end{align}
となるため，
\begin{align}
    {|I|}_{\mathrm{Q}4\mathrm{f}3} = 39
\end{align}
となる．
このように定義した密度${|I|}_{\mathrm{T}}$を用いて，同じ範囲$J \in \R$に対して異なる数値型$T_1,T_2$で計算を行うことを考える．
ただし，
\begin{equation}
    J \subset (m_{T_1}, M_{T_1}) \cap (m_{T_2}, M_{T_2})
\end{equation}
とする．
また，
\begin{equation}
    \label{eq:density_compare}
    {|J|}_{T_1} < {|J|}_{T_2}
\end{equation}
と仮定する．

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \node[text=red] (A-4) at (-3.5,0) {$\bigtriangleup$};
        \node[text=red] (A-3) at (-2.2,0) {$\bigtriangleup$};
        \node[text=red] (A-2) at (-2,0) {$\bigtriangleup$};
        \node[text=red] (A-1) at (-1,0) {$\bigtriangleup$};
        \node[text=red] (A0) at (0,0) {$\bigtriangleup$}; 
        \node[text=red] (A1) at (1,0) {$\bigtriangleup$};
        \node[text=red] (A2) at (2.1,0) {$\bigtriangleup$};
        \node[text=red] (A3) at (2.6,0) {$\bigtriangleup$};
        \node[text=red] (A4) at (3.1,0) {$\bigtriangleup$};
        \node[text=red] (A5) at (4.7,0) {$\bigtriangleup$};
        \node[text=red] (A6) at (5.5,0) {$\bigtriangleup$};
        \draw [->, thick] (-7,0) -- (7,0);
        \node[left] (X) at (8,0) {$x$};
        \node[text=blue] (B-5) at (-5.7,0) {$\square$};
        \node[text=blue] (B-4) at (-4.5,0) {$\square$};
        \node[text=blue] (B-3) at (-3.1,0) {$\square$};
        \node[text=blue] (B-2) at (-2.5,0) {$\square$};
        \node[text=blue] (B-1) at (-1.3,0) {$\square$};
        \node[text=blue] (B0) at (0.4,0) {$\square$};
        \node[text=blue] (B1) at (1.5,0) {$\square$};
        \node[text=blue] (B2) at (3.2,0) {$\square$};
        \node[text=blue] (B3) at (4.5,0) {$\square$};
        \node[text=blue] (B4) at (6.5,0) {$\square$};
        \draw[very thick] (-2.5,-1) -- (-3,-1) -- (-3,1) -- (-2.5,1);
        \draw[very thick] (2.5,-1) -- (3,-1) -- (3,1) -- (2.5,1);
        \node (J) at (0,1) {$J$};
        \node[text=blue] (B) at (7,1.5) {$\square$};
        \node (Bname) at (7.5,1.5) {$T_{1}$};
        \node[text=red] (A) at (7,1.1) {$\bigtriangleup$};
        \node (Aname) at (7.5,1.1) {$T_{2}$};
        \end{tikzpicture}
        \caption{${|J|}_{T_1} < {|J|}_{T_2}$を満たす場合のイメージ図：横軸は数直線，青色の\textcolor{blue}{$\square$}は数値型($T_{1}$)の表せる数，赤色の\textcolor{red}{$\bigtriangleup$}は数値型($T_{2}$)の表せる数}
\end{figure}
式(\ref{eq:density_compare})を満たすような範囲$J$において数値計算を行う場合，密度の高い数値型$T_{2}$の方が数値型$T_{1}$よりも計算の際に生じる誤差が少ないと予想される．
つまり，$J$において数値型$T_1$で行なった計算と，数値型$T_2$で行なった計算の誤差をそれぞれ$e_1$，$e_2$とすると，
\begin{equation}
    e_2 < e_1
\end{equation}
となると考えられる．
次章で行う数値実験は，倍精度浮動小数点(Float64)よりも64bitの固定小数点の方が密度が高いと思われる範囲での数値計算を行った．
\end{comment}